// const express = require('express');
// const cors = require('cors');
// const app = express();
// app.use(express.json());
// app.get('/', (req, res) => res.send('linked!'));
// app.listen(8001, () => console.log('Server Up and running at 8001'));



// https://realizetoday.tistory.com/46
const express = require('express');
const app = express();
const https = require('https');
const fs = require('fs');
const { constants } = require('os');
require('dotenv').config();
const LINE_TOKEN = process.env.LINE_ACCESS_TOKEN;
const ssl_options = {
    ca: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/fullchain.pem'),
    key: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/privkey.pem'),
    cert: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/cert.pem')
};
app.use(express.json());
app.use(express.urlencoded({
    extended: true
}))
// app.get('/', (req, res) => res.send('linked!'));

app.get("/", (req, res) => {
    res.sendStatus(200)
})

app.get("/deposit", (req, res) => {
    console.log('deposit deposit');
    res.send('deposit deposit')
})

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ÌÖîÎ†àÍ∑∏Îû®
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


// npm Î™®Îìà Ìò∏Ï∂ú
const TelegramBot = require('node-telegram-bot-api');

// `botFather`Í∞Ä Ï†úÍ≥µÌïú `token`ÏúºÎ°ú API ÌÜµÏã†Ïóê ÏÇ¨Ïö©ÌïúÎã§
const TELEGRAM_TOKEN= process.env.TELEGRAM_TOKEN; 

// ÏÉàÎ°úÏö¥ 'bot' Ïù∏Ïä§ÌÑ¥Ïä§Î•º ÏÉùÏÑ±Ìï¥ 'polling'ÏúºÎ°ú ÏóÖÎç∞Ïù¥Ìä∏Î•º fetch ÌïòÍ≤å ÌïúÎã§
const telebot = new TelegramBot(TELEGRAM_TOKEN, {polling: false});

const url = 'https://loveplant.shop';

// Ï†ïÍ∑úÏãùÏúºÎ°ú '/echo'Î•º ÌåêÎ≥ÑÌïòÍ≥† Í∑∏ Îí§Ïóê Ïñ¥Îñ§ Î©îÏãúÏßÄÎì† 'msg'Ïóê Îã¥ÎäîÎã§
telebot.onText(/\/echo (.+)/, (msg, match) => {   
    const chatId = msg.chat.id;
    const res = "Í∫ÑÏïÖ: "+match[1]; 
    // ÏãùÎ≥ÑÎêú "msg"Îäî Î≥¥ÎÇ¥Ïò® Ï±ÑÌåÖÎ∞©('chatId')ÏóêÍ≤å ÏïµÎ¨¥ÏÉàÏ≤òÎüº Ïû¨Ï†ÑÏÜ°ÌïúÎã§ ("Í∫ÑÏïÖ: 'msg'")
    telebot.sendMessage(chatId, res);
});

// telebot.on('deposit', query => {
//     console.log('deposit query:', query);
// })

// telebot.on('withdrawal', query => {
//     console.log('withdrawal query:', query);
// })

telebot.on('message', (msg) => {
    console.log('msg:', msg);
    const chatId = msg.chat.id;
    const chatText = msg.text;

    switch (chatText) {
        case 'menu':
        case 'Menu':
        case 'Î©îÎâ¥':
            const menuOption = {
                reply_markup: {
                    inline_keyboard: [
                        [
                            {
                                text: 'üîÜ ÏòàÏπòÌïòÍ∏∞',
                                callback_data: 'deposit'
                            },
                            {
                                text: 'üî∑ Ï∂úÍ∏àÌïòÍ∏∞',
                                callback_data: 'withdrawal'
                            }
                        ],
                        [
                            {
                                text: 'üíµ ÌôòÏ†ÑÌïòÍ∏∞',
                                callback_data: 'exchange'
                            },
                            {
                                text: 'üí∞ ÎÇ¥ ÏõîÎ†õ',
                                callback_data: 'wallet'
                            }
                        ]
                    ]
                }
            }

            telebot.sendMessage(msg.chat.id, "Î©îÎâ¥ÏûÖÎãàÎã§.\n\nÏñ¥Ï©åÍ≥† Ï†ÄÏ©åÍ≥† Î∏îÎùºÎ∏îÎùºÏûÖÎãàÎã§ÎûåÏ•ê", menuOption)
            .then((value) => {
                console.log('bot.sendMessage() then()');
                if (telebot.isPolling()) {
                    console.log('isPolling true');
                    telebot.stopPolling().then(() => {
                        telebot.openWebHook();
                    });
                } else {
                    console.log('isPolling false');
                    telebot.openWebHook();
                }
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code);  // => 'ETELEGRAM'
                console.log(error.response.body); // => { ok: false, error_code: 400, description: 'Bad Request: chat not found' }
            });
            
            break;

        default:
            // send a message to the chat acknowledging receipt of their message
            telebot.sendMessage(chatId, 'Ïûò Î™®Î•¥Í≤†Ïñ¥Ïöî.')
            .then((value) => {
                console.log('bot.sendMessage() then()');
                if (telebot.isPolling()) {
                    console.log('isPolling true');

                    // telebot.stopPolling()
                    // .then(() => {
                    //     console.log('stopped Polling');
                    //     telebot.openWebHook();
                    // })
                    // .catch((error) => {
                    //     console.log("stopPolling() catch() error.code:", error.code); 
                    //     console.log(error.response.body); 
                    // });

                } else {
                    console.log('isPolling false');
                    telebot.openWebHook();
                }
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code);  // => 'ETELEGRAM'
                console.log(error.response.body); // => { ok: false, error_code: 400, description: 'Bad Request: chat not found' }
            });
    } 
});

telebot.setWebHook(`${url}/bot${TELEGRAM_TOKEN}`);

if (telebot.hasOpenWebHook()) {
    console.log('webhook open.');
    // telebot.closeWebHook();
} else {
    console.log('webhook closed.');
    // telebot.openWebHook(); // Error: EFATAL: WebHook and Polling are mutually exclusive
}

// We are receiving updates at the route below!
app.post(`/bot${TELEGRAM_TOKEN}`, (req, res) => {

    if (telebot.hasOpenWebHook()) {
        // telebot.closeWebHook();
        console.log('webhook open.');
    } else {
        console.log('webhook closed.');
        if (telebot.isPolling()) {
            console.log('isPolling true');
            telebot.stopPolling().then(() => {
                telebot.openWebHook();
            });
        } else {
            console.log('isPolling false');
            telebot.openWebHook();
        }
        
    }

    console.log('telegram app.post("/bot/token")');
    console.log('req.body:', req.body);
            // body: {
            //     update_id: 75325093,
            //     callback_query: {
            //       id: '8429873056235978936',
            //       from: [Object],
            //       message: [Object],
            //       chat_instance: '3570761467547817066',
            //       data: 'deposit'
            //     }
            // },

    switch (req.body.callback_query.data) {
        case 'deposit':
            console.log('ÏòàÏπòÌïòÍ∏∞ ÌÅ¥Î¶≠');
            telebot.sendMessage(req.body.callback_query.from.id, 'ÏòàÏπòÌïòÍ∏∞Î•º ÌÅ¥Î¶≠ÌïòÏÖ®Íµ∞Ïöî!')
            .then((value) => {
                console.log('bot.sendMessage() then() value:', value);
                telebot.closeWebHook();
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code); 
                console.log(error.response.body); 
            });

            break;

        case 'withdrawal':
            console.log('Ï∂úÍ∏àÌïòÍ∏∞ ÌÅ¥Î¶≠');
            telebot.sendMessage(req.body.callback_query.from.id, 'Ï∂úÍ∏àÌïòÍ∏∞Î•º ÌÅ¥Î¶≠ÌïòÏÖ®Íµ∞Ïöî!')
            .then((value) => {
                console.log('bot.sendMessage() then() value:', value);
                telebot.closeWebHook();
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code); 
                console.log(error.response.body); 
            });

            break;

        case 'wallet':
            console.log('ÎÇ¥ ÏõîÎ†õ ÌÅ¥Î¶≠');
            telebot.sendMessage(req.body.callback_query.from.id, 'ÎÇ¥ ÏõîÎ†õÏùÑ ÌÅ¥Î¶≠ÌïòÏÖ®Íµ∞Ïöî!')
            .then((value) => {
                console.log('bot.sendMessage() then() value:', value);
                telebot.closeWebHook();
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code); 
                console.log(error.response.body); 
            });

            break;
            
        case 'exchange':
            console.log('ÌôòÏ†ÑÌïòÍ∏∞ ÌÅ¥Î¶≠');
            telebot.sendMessage(req.body.callback_query.from.id, 'ÌôòÏ†ÑÌïòÍ∏∞Î•º ÌÅ¥Î¶≠ÌïòÏÖ®Íµ∞Ïöî!')
            .then((value) => {
                console.log('bot.sendMessage() then() value:', value);
                telebot.closeWebHook();
            })
            .catch((error) => {
                console.log("bot.sendMessage() catch() error.code:", error.code); 
                console.log(error.response.body); 
            });

            break;
    }

    telebot.processUpdate(req.body);
    res.sendStatus(200);
});

telebot.on('polling_error', (error) => {
    console.log("polling_error:", error.code);  // => 'EFATAL'
});

telebot.on('webhook_error', (error) => {
    console.log("webhook_error:", error.code);  // => 'EPARSE'
});

// telegram
app.post("/telebot22", function(req, res) {
    console.log('telebot!!');
    res.send("HTTP POST request sent to the webhook URL! (telegram)");
})




////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ÎùºÏù∏
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////



// line
app.post("/webhook", function(req, res) {
    res.send("HTTP POST request sent to the webhook URL! (line)");
    // console.log('req:', req);
    // console.log('res:', res);

    const bitcoin = "0.001";
    const ton = "15";

    var eventObj = req.body.events[0];
    var source = eventObj.source;
    var message = eventObj.message;
    console.log('eventObj:', eventObj);
    console.log('eventObj.type:', eventObj.type);
    console.log('source:', source);
    console.log('message:', message);

    // Message data, must be stringified
    // Î©îÎâ¥
    const menuData = JSON.stringify({
        replyToken: req.body.events[0].replyToken,
        messages: [
            {
                "type": "template",
                "altText": "ÏòàÏπòÌïòÍ∏∞",
                "template": {
                    "type": "buttons",
                    "title": "üí∞ ÎÇ¥ ÏõîÎ†õ",
                    "text": `\nBitcoin: ${bitcoin} BTC\n\nToncoin: ${ton} TON`,
                    "actions": [
                        {
                            "type": "message",
                            "label": "ÏòàÏπò",
                            "text": "ÏòàÏπòÌïòÍ∏∞"
                        },
                        {
                            "type": "message",
                            "label": "Ï∂úÍ∏à",
                            "text": "Ï∂úÍ∏àÌïòÍ∏∞"
                        },
                        {
                            "type": "message",
                            "label": "ÌôòÏ†Ñ",
                            "text": "ÌôòÏ†ÑÌïòÍ∏∞"
                        }
                    ]
                }
            }
        ]
    })

    // ÏòàÏπò
    const depositData = JSON.stringify({
        replyToken: req.body.events[0].replyToken,
        messages: [
            {
                "type": "template",
                "altText": "ÏòàÏπòÌïòÍ∏∞",
                "template": {
                    "type": "buttons",
                    "title": "üîÜ ÏòàÏπòÌïòÍ∏∞",
                    "text": "ÏòàÏπòÌïòÍ∏∞ Î©îÎâ¥ÏûÖÎãàÎã§.",
                    "actions": [
                        {
                            "type": "message",
                            "label": "ÏòàÏπò1",
                            "text": "ÏòàÏπòÌïòÍ∏∞1"
                        },
                        {
                            "type": "message",
                            "label": "ÏòàÏπò2",
                            "text": "ÏòàÏπòÌïòÍ∏∞2"
                        },
                        {
                            "type": "message",
                            "label": "Îí§Î°úÍ∞ÄÍ∏∞",
                            "text": "Îí§Î°úÍ∞ÄÍ∏∞"
                        }
                    ]
                }
            }
        ]
    })

    // Ï∂úÍ∏à
    const withdrawalData = JSON.stringify({
        replyToken: req.body.events[0].replyToken,
        messages: [
            {
                "type": "template",
                "altText": "Ï∂úÍ∏àÌïòÍ∏∞",
                "template": {
                    "type": "buttons",
                    "title": "üî∑ Ï∂úÍ∏àÌïòÍ∏∞",
                    "text": "Ï∂úÍ∏àÌïòÍ∏∞ Î©îÎâ¥ÏûÖÎãàÎã§.",
                    "actions": [
                        {
                            "type": "message",
                            "label": "Ï∂úÍ∏à1",
                            "text": "Ï∂úÍ∏àÌïòÍ∏∞1"
                        },
                        {
                            "type": "message",
                            "label": "Ï∂úÍ∏à2",
                            "text": "Ï∂úÍ∏àÌïòÍ∏∞2"
                        },
                        {
                            "type": "message",
                            "label": "Îí§Î°úÍ∞ÄÍ∏∞",
                            "text": "Îí§Î°úÍ∞ÄÍ∏∞"
                        }
                    ]
                }
            }
        ]
    })

    // Ï∂úÍ∏à
    const exchangeData = JSON.stringify({
        replyToken: req.body.events[0].replyToken,
        messages: [
            {
                "type": "template",
                "altText": "üíµ ÌôòÏ†ÑÌïòÍ∏∞",
                "template": {
                    "type": "confirm",
                    "text": "ÌôòÏ†ÑÌïòÏãúÍ≤†ÏäµÎãàÍπå?",
                    "actions": [
                        {
                            "type": "message",
                            "label": "Ïòà",
                            "text": "Ïòà"
                        },
                        {
                            "type": "message",
                            "label": "ÏïÑÎãàÏò§",
                            "text": "ÏïÑÎãàÏò§"
                        }
                    ]
                }
            }
        ]
    })

    // Î™®Î¶Ñ
    const unknownData = JSON.stringify({
        replyToken: req.body.events[0].replyToken,
        messages: [
            {
                "type": "text",
                "text": "Ïûò Î™®Î•¥Í≤†Ïñ¥Ïöî"
            }
        ]
    })


    // If the user sends a message to your bot, send a reply message
    if (eventObj.type === "message") {

        let dataString;

        if (message.text == "ÏòàÏπòÌïòÍ∏∞") {
            dataString = depositData;
        } else if (message.text == "Ï∂úÍ∏àÌïòÍ∏∞") {
            dataString = withdrawalData;
        } else if (message.text == "Î©îÎâ¥" || message.text == "Îí§Î°úÍ∞ÄÍ∏∞") {
            dataString = menuData;
        } else if (message.text == "ÌôòÏ†ÑÌïòÍ∏∞") {
            dataString = exchangeData;
        } else {
            dataString = unknownData;
        }

        // Request header
        const headers = {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + LINE_TOKEN
        }

        // Options to pass into the request
        const webhookOptions = {
            "hostname": "api.line.me",
            "path": "/v2/bot/message/reply",
            "method": "POST",
            "headers": headers,
            "body": dataString
        }

        // Define request
        const request = https.request(webhookOptions, (res) => {
            res.on("data", (d) => {
                process.stdout.write(d)
            })
        })

        // Handle error
        request.on("error", (err) => {
            console.error(err)
        })

        // Send data
        request.write(dataString)
        request.end()

    } 
})

// const server = https.createServer(ssl_options, app).listen(443, () => console.log('Server Up and running at 443'));

// Create an HTTPS service identical to the HTTP service.
https.createServer(ssl_options, app).listen(443, () => console.log('Server Up and running at 443'));



// // https://m.blog.naver.com/PostView.naver?isHttpsRedirect=true&blogId=m950827&logNo=221391084929
// /************************  express ÏÇ¨Ïö©  ************************/

// var express = require('express');
// var https = require('https'); //http Î™®Îìà ÎåÄÏã† https Î™®ÎìàÏùÑ ÏÇ¨Ïö©Ìï©ÎãàÎã§.
// var fs = require('fs');

// var server = express();

// const ssl_options = {
//   ca: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/fullchain.pem'),
//   key: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/privkey.pem'),
//   cert: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/cert.pem')
// };

// /*
// //Ïù¥ Î∂ÄÎ∂ÑÏóê routerÎì± ÏÑ§Ï†ïÏùÑ Ìï¥Ï£ºÎ©¥ Îê©ÎãàÎã§.
// */

// https.createServer(ssl_options, server, (req, res) => {
//   console.log('ÌïÑÏöîÌïú ÏΩîÎìú ÎÑ£Í∏∞');
// }).listen(443, () => {
//   console.log('ÏÑúÎ≤Ñ Ìè¨Ìä∏: 443 ...');
// });






// // https://gamsunghacker.tistory.com/150
// var express = require('express');
// const https = require('https');
// const http = require('http');
// const fs = require('fs');
// var app = express();
// app.use(express.json());
// app.use(express.urlencoded({ extended: false }));
// // var createError = require('http-errors');

// // // catch 404 and forward to error handler
// // app.use(function (req, res, next) {
// //     next(createError(404));
// // });

// // // Create an HTTP service.
// // http.createServer(app).listen(3000);


// const ssl_options = {
//   ca: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/fullchain.pem'),
//   key: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/privkey.pem'),
//   cert: fs.readFileSync('/etc/letsencrypt/live/loveplant.shop/cert.pem')
// };

// // Create an HTTPS service identical to the HTTP service.
// https.createServer(ssl_options, app).listen(443, () => console.log('Server Up and running at 443'));